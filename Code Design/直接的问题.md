# 直接的问题

## 用户如何执行其他不能与单个对象关联的操作

某些必需的用户操作显然不与任何实例对象有关联, 例如创建一个新的实例, 查找现有的实例, 创建一个匹配某些模式的的实例列表. 但是, 所有这些操作都可以被认为等同于面向对象编程中的类方法（在Java称为“静态”方法）. 因此,除了公开单个对象实例外,裸对象系统还应该向用户提供业务对象**类的直接表示**,并通过该表示向用户提供对适当类方法(静态方法)的访问. 在图3-2中,最左边窗口中的图标表示裸对象类(Booking等), 而其他窗口和嵌入其中的图标表示单个裸体对象实例,其中一个类图标(cities)的弹出菜单显示了创建新城市、查找现有城市等的类方法,
类似地,可以将任何领域对象集合作为一个对象来处理,从而使用户能够查看和操作它们(就像在面向对象编程语言中处理集合一样),在图3.2中,由四个红色小块组成的图标表示一个集合——在本例中是五个城市对象集合,

## 通用表示层如何允许对象的替代视觉表示

模型视图控制器模式背后的动机之一是允许相同对象的替代可视化表示,例如表格或图形, 普遍的观点是,这是一个共同的需求,尽管这种观点偶尔也会受到挑战,例如:
> 你的工作中有多少次出现这个问题？ 在谈论用户界面的面向对象架构时,有数百个（如果不是数千个）程序员,当我提出这个问题时,只有两三个人举手, 如果我需要一个没有数据含义概念的通用演示程序 我会买Excel或Quattro Pro的副本, 我不会写一个程序, 事实是数据具有意义 - 它不仅仅是一个任意的数字集合,对于给定的一组数据,我认为只有一种“最佳”方式来表示特定问题域, 如果没有“最好的”方式,那么选择一种“好”的方式, 很少需要这种程度的灵活性. ---Holub

然而,必须承认,在某些情况下,生成替代视觉表示的能力是一个真正的需求,在这些情况下,如何让用户可以使用其他通用的可视表示,而不需要在查看机制中进行编程干预,也不需要将特定于用户界面的代码合并到域型中.
解决方案是利用编程接口,例如,在Java编程语言中,一个类只能继承一个超类的功能,但是它可以实现任意数量的接口,实现接口意味着对象可以在指定接口的任何上下文中使用,而不管对象继承自哪个超类.

因此,可以基于特定的对象接口定义特定的可视化表示.任何实现该定义接口的对象都能够呈现为该特定的可视表单,并且自动为用户提供了这样做的选项.
图3-3所示的屏幕截图取自能源交易应用程序,其中交易“位置”在欧洲地图上显示为图标. 每个图标代表一个对象并且功能齐全 - 可以右键单击以显示提供其行为的弹出菜单,包括打开显示该对象的属性和关联单独视图的功能.为了实现这一点,定义了“空间”接口,使得每个实现Spatial接口的对象的任何集合（其仅需要对象提供`getLattidude()`和`getLongitude()`方法）可以选择性地显示在它们的正确位置.地图的背景
类似地,任何数值对象的集合可以可选地显示为图形,该表示仍然提供对每个对象的功能的完全访问.或者,实现“日期”接口的任何对象集合都可以选择以日历表示形式显示.

## 通用表示层的概念如何适应支持多种形式用户平台的需求
  
模型视图控制器模式的另一个动机是便于将系统移植到不同的客户端平台.使用MVC,这样的端口涉及到更改视图和控制器对象,但不涉及模型对象.

*Naked Object Architecture*和*Naked Objects framework*的初始实现都假定系统是从具有高分辨率图形显示的PC和鼠标（或等效的指针设备）访问的. 此外,在这两种情况下,通用表示层或查看机制都是用Java编写的（虽然完全不同）需要作为独立应用程序下载到PC,或作为在浏览器中运行.

许多组织采用了一种策略,即所有新的业务应用程序都应该是瘦客户端,这在大多数情况下意味着它必须在浏览器中运行,在某些情况下意味着它必须在原生HTML中运行,从而排除了使用Java applet.有人认为,样的策略消除了在客户端维护软件的需要,而且还促进了广域网上的操作.(这里没有为这些论点的逻辑辩护).

更复杂的是,越来越多的人希望让业务应用程序可以从广泛的用户平台和设备上访问,包括个人数字助理(pda)和第三代移动电话.

事实上,裸对象更容易解决这个问题.考虑到自动反映底层领域对象模型的通用查看机制的想法,很有可能设想替代的通用查看机制,每个机制都适合特定查看平台的能力.在输出和输入方面,这些平台中的一些可能供比(比如)PC更低的设备和用户之间的通信带宽.拖放可能不可行——例如手持设备.然而,为了与裸对象保持一致,用户界面不需要使用图标和直接操作.用户界面只需要保留用户直接处理域对象并显式调用这些对上的行为的概念.换句话说, 交互方式就是"对象方法"(或"动名词"). 例如,很有可能将每个对象设想为一个web页面,并将每个行为设想为该页面上的一个热按钮.

## 在不允许使用用例控制器的情况下,裸对象如何支持业务流程的思想

裸对象的定义要求所有的业务功能都必须封装在实体对象中,而不是封装在位于这些实体之上的用例控制器(或其他大致等同的结构)中.稍后将会讨论,这种方法为用户提供了一个更具“表现力”(或有控制力)的用户面.

然而,在某些情况下,确实需要某种顺序：例如,强制遵守受监管的业务流程（“必须在合同约束前两周向客户提供完整的书面报价”）或 基本的业务逻辑（“在检查可用性之前无法确认预订”）.

这是通过区分实体对象的两大类型或原型:“有目的对象”和“无目的对象”来实现的.无目的对象的一些示例有产品、客户、员工和位置.对于无目的对象,对象的**状态**通过其各种属性和关联的聚集来**隐含地定义**.些无目的对象的状态会随着时间的推移而改变,并且这种状态会持续存在,但是**这些改变不会朝着任何特定的方向前进**.它们可以被认为是随机的.

相反,有目的对象的**状态通常是明确定义的**,并且通常由单个字段表示,该字段可以采用有限的一组预定值中的一个. 而且,这种状态通常在预定的方向上变化;这通常使用状态转换图定义,状态转换图指定对象一个预定状态移动到另一个预定状态的条件. 因此,订单可以从查询状态,已提交状态,已发货状态到已开票状态.状态可能偶尔会退回,或者订单可能会提前终止;但是**有明确的预期方向**.

这种有目的对象的概念与Coad所确定的“时刻间隔”(moment-interval)原型大致相似,(无目的对象常对应于“人、地点或事物”原型),这种原型可以作为替代,Wirfs-Brock定义的原型也是如此.

可能有人会说,有目的的对象只是用例控制器换个名称.然而它们一个重要的区别.在裸对象系统中,无目的对象和有目的对象都是实体对象.它们被显式地呈现给用户作为对象(例如作为图标).它们被设置为持性(至少在默认情况下).即使它们达到了预期的最终状态,它们仍然作为对象存在.在对象建模的大多数方法中,一旦事务、流程或用例完成,就没有办法显式地引用它.在裸体对象系统中,这些活动本身就显示为象：它们可以被查看和检查,并且可以调用它们在状态下保持有效的任何行为. 因此,即使在进行（银行）转账之后,用户也可以检查它,决定对其进行逆转,收取费用,或者通知客户其成功完成 - 所有方法都可以然地封装在该转账(Transfer)对象中 .

任何描述业务活动并且可以很容易地转换成名词的动词都是有目的对象的主要候选对象.因此,用户可能需要调整(Adjust Verb)价格(Price).但他们也会很乐意谈论价格调整(PriceAdjustment).这个语法会示把价格调整看作一个实例化的实体对象呈现给用户可见(例如,作为一个图标).将银行转账视为持续实体对象而不是临时控制器的想法并不新颖(Riel提出了以这种方式处理转账、取款和存款的情况),但裸对象使这种思维方式的优势更加清晰.

## 如果核心对象直接公开给用户,如何能够限制它在特定用户或特定上下文中属性和行为

使用裸对象,领域对象及其功能将直接公开给用户.但是,在许多情况下,并不希望对所有属性或功能都对用户可用.例如

  1. 特定用户角色可能没有资格查看所有数据或调用对象上的所有操作
  2. 如果一个对象在许多上下文中使用(例如客户对象),它可能获得许多属性和行为.显它们会导致不必要的屏幕混乱、数据库访问或网络传输.
  3. 当对象处于某些状态时,特定的属性或行为应该不可用.例如,在提供了足够的信息前,不应该试图检查预订(Booking)的可用性.(如前所述,这主要适用于有目的对象.这一需求可以概括为对对象功能进行选择性查看的需要
如果用户界面是根据业务对象的定义自动生成的,并且不允许编程干预,那么似乎不可能提供对对象能力的选择性查看.解决方案是在域对象本身上提供一些控制可用性的能力:整个对象类、该类的特定实例以及该类上的单个方法.(请注意,假设采取正常的面向对象实践,即保持所有变量私有——只能通过“访问器”和“赋值器”方法(如`get`和`set`)访问——那么对方法可用性的控制就能控制对属性和关联以及更丰富行为的访问.)

在`Naked Objects framework`中,这是通过允许任何方法具有相应的元方法(about method)来实现的. 因此,`Booking`对象上的`actionConfirm()`方法可以具有相应的`aboutActionConfirm()`方法来控制其可用性. 此`aboutActionConfirm()`方法可以根据Booking对象的状态控制可用性,或者可以将决策委派给查找用户授权的授权服务器. 在观看机制的一个版本中,通过使菜单动作变灰,呈现特定字段（属性）不可编辑或从视图中排除它来向用户发信号通知不可用性. 元方法也可以返回缺乏可用性的原因,查看机制可以将其呈现为“气球”帮助或类似.

## 如何从用户界面调用多个参数方法

业务对象上的任何无参方法都可以作为弹出菜单上的选项自动呈现给用户访问.可以使用拖放手势来呈现可访问的单个参数方法——将对象A拖放到对象B上将调用B上的方法,该方法的参数类型为A.(如果有不止一个这样的方法,那么用户界面可以生成一个弹出菜单,用户可以从中选择).但是多参数方法呢?3.1节中介绍的两个框架在处理这个问题的方式上有所不同.

`Naked Objects framework`(在编写本文时)没有使用对话框,因此不为用户提供任何方法来调用业务对象上的多参数方法.有趣的是,跨各种应用程序部署框架的经验表明,这并不像一开始看起来那么有限制.

考虑这样一个银行系统的例子,其中Account是业务对象的一个类,具有存款、取款、生成报表和应用费用等方法.系统应该如何处理帐户之间的资金转移?常规的设计可能将transfer实现为位于对象之上的用例控制器,但这与裸对象方法相反.然而,将转账作为一种方法(在发起转账的账户中)将需要至少两个参数:转账金额和转账账户.

解决方案是将`Transfer`作为有目的对象实现.它的属性是两个帐户,要转移的金额和日期时间. 然后,`Account`对象有一个`CreateNewTransfer`方法,该方法会创建个新的Transfer实例,并填充“from”帐户. 或者,用户可以通过将一个帐户拖到另一个户上来快捷方式,这会返回一个新的Transfer对象,其中填充了“from”和“to”字段. 在定要传输的数量之后,用户然后在Transfer对象上调用'Execute'或'Make it so'方法.