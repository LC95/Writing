# 一种面对形式的编程
## 名字灾难
?
日常编程中, 随着我们定义的逐渐复杂. 最终我们总会需要各式各样名字来帮我们理清思绪. 这时面向对象编程就变成了面向名字编程, 识别各种结构并为其取名以及识别某种名字的结构为OOP的重中之重.

在认识一个名字之前, 我们**总是要**认识其组成结构的所有名字, 这一步是递归的, 
最终我们会回到int , float,加减乘除等等认识. 在这递归的步骤中, 现实经验能够帮助加快这一速度, 但是认识的过程一步不能减少. 这就是我要说的命名灾难.

在命名一个结构之前, 我们**不能**了解整个系统中的全部名字, 我们的命名是不考虑系统的. 在一个系统当中, 名字及其意义的变动, 往往是牵一发而动全身. 就像一个拼图一样, 你改变了一个方块, 也就意味着要改另一个方块, 最终这种改变会扩散至整个系统. 当然, 这说的是在系统相对封闭的情况下, 在拼图只有那么大的情况下.

有人说命名是计算机科学中最头疼的三件大事中的一件, 我认为说的很对. 在我看来, 命名从来该不是程序员的乾纲独断. 一个类叫什么也不重要, 重要的是有多少人认同了这命名, 要让所有人认同这个名字也就要让所有人识别这个结构. 约定俗成, 这是命名的重中之重, 然而这项工作在实践上是困难的.

OOP中, 最难以令人规避的是名字的多意义性. 解决办法就是给名字加上一节标注, 在C#中叫做命名空间. 这好比我们人类有多重的分类方式, 一只小猫, 我们可以认为是哺乳动物, 也可以认为是陆生动物, 它被解释成什么取决于我们的用途. 在常见的业务层编程中, 一个名字(如订单)可以被定义为多个类. 在物流系统中, 订单持有一个片面的意义; 在结算系统中订单又持有一个片面的意义. 不同的业务部门对名字的解释可谓是盲人摸象. 片面化是名字解释当中最最关键的特征, 是不可缺少. 

我上面说到盲人摸象, 那也得是真的存在一头大象. 有没有可能事实完全相反. 我们只是刚好把不同结构的东西跟这个名字对应起来. 我觉得有可能, 订单就是一个很好的例子.


## C# 描述

我现在想到了一种技术性的道路，那就是对代码段进行签名, 首先要达到的效果是切面编程。

例如一个简单的程序

```C#
public void Main(){
	int a = 1;
	while(a < 10>){
		a++;
		Console.WriteLine(a);
	}
}
```

现在我们要用另一种方式实现上述代码, 我大胆的模仿接口的命名法，将特征的命名首字母写成`S`, 并用`~`将其与其他方法区别开来, `~`还是C#中的终结标识符  

```C#
//src/TraitTest/Traits
public trait SSection;//trait为特征关键字， 特征并不关心参数的类型，它只有一个名字。我取名Section（切面）

public void Main(){
	int a = 1;
    ~SSection {
		Console.WriteLine(a);
	}
}

//为特征的前方设定一段代码
//src/TraitTest/TraitImpl/SMethodToInt
public static ~SSection(int a) {
	while(a < 10){
		action;	
		a++;
	}
}

//另一个面对特征的实现
public static ~SSection(double a, Action<double> action){
	while(a < 10){
		action;
		a++;
	}
}

```
我想C#的编译器应当有能力将Section段的内容编译成Lambda表达式`Expression<Func<int,Void>>`,编译的时候， 编译器检测到有一个特征实现（int的那一个）, 将代码注入其中。这一过程是静态的。

## 不考虑返回值的情况下，这种语法带来一些问题  
1. 考虑以下泛型方法
   ```C#
   public static void Print(T a){
	   ~SSection{
      	  
	   }
   }

   public static ~SSection(int a, Action<int> action)
   ```
   泛型方法是在运行时期间创造的，为了执行我们设定的特征补充代码，我们需要修改运行时使其生成具体泛型方法时注入我们的代码
2. 多参数问题，考虑以下代码
   ```C#
   public static void Print(int a, int b){
	   int c = 0;
	   ~SSection {
		   c = a + b;
	   }
   }
   //以上我们方法定义了两个参数, 我们想输出两个参数
   public static ~SSection<TA,TB>(TA a, TB b){
	   Console.WriteLine($"First arg is {a}");
	   Console.WriteLine($"Second arg is {b}");
	   action; //action关键字代表了要修饰的函数代码
   }
   //假如我们最终执行了Print(1,2)方法，那么到底是1先输出还是2先输出呢？
   ```
   上边的问题涉及到编译器怎么理解`var sum = a + b`这条，是a,b,c谁来对应第一个参数。为了避免困惑，我们可以显式地标出顺序:
   ```C#
   ~SSection(a,b,c){
		c = a + b;
   }
   ```
3. 多适应问题，一个特征遇到了多个满足的实现, 考虑以下代码
   ```
    public static void Print<TA, TB>(TA a, TB b){
	    ~SSection {
		}
    }
	//方法一, 有两个基类参数
	public static ~SSection(Base a, Base b) {

	}

	//方法二，有一个基类，一个子类参数
	public static ~SSection(Base a, Child b) {

	}

	//方法三，两个子类参数
	public static ~SSection(Child a, Child b) {

	}

	//方法四，两个泛型参数
	public static ~SSection(TA a, TB b){

	}

	//方法五，三个泛型参数
	public static ~SSection(TA a, TB b, TB c)

   ```
   到底该执行哪一个方法呢？对此我要告诉大家一个规定的顺序，我们总是按照参数个数匹配，然后按照具体类》基类》泛型的优先级来匹配。考虑如下传参`Print(new Child(), new BaseClass())`;它应当应适用哪种方法呢？方法二和方法一都能够应用，但是就具体程度来说，方法二规定的更为具体。
4. 覆盖问题，例如你要为引用的类库的某一特征编写一些拓展，可是其他作者已经先于你写了相同参数的实现。那怎么办？我能覆盖别人的实现吗？  
   面对这种情况，作者可以选择将自己的Trait设为Internal，另外编译器需要拥有在全体代码检测面对同一特征的相同签名方法的能力，并禁止出现这种情况;
5. Reflection和在Emit中的执行情况？我还没想好~~
6. 特征中的嵌套的特征，考虑如下代码：
	```C#
	public static void Do<T1, T2>(){
		~SA{
			...
			~SB{
				...
			}
		}
	}
	```
