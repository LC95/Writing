# 一种面对形式的编程
## 名字灾难
?
日常编程中, 随着我们定义的逐渐复杂. 最终我们总会需要各式各样名字来帮我们理清思绪. 这时面向对象编程就变成了面向名字编程, 识别各种结构并为其取名以及识别某种名字的结构为OOP的重中之重.

在认识一个名字之前, 我们**总是要**认识其组成结构的所有名字, 这一步是递归的, 
最终我们会回到int , float,加减乘除等等认识. 在这递归的步骤中, 现实经验能够帮助加快这一速度, 但是认识的过程一步不能减少. 这就是我要说的命名灾难.

在命名一个结构之前, 我们**不能**了解整个系统中的全部名字, 我们的命名是不考虑系统的. 在一个系统当中, 名字及其意义的变动, 往往是牵一发而动全身. 就像一个拼图一样, 你改变了一个方块, 也就意味着要改另一个方块, 最终这种改变会扩散至整个系统. 当然, 这说的是在系统相对封闭的情况下, 在拼图只有那么大的情况下.

有人说命名是计算机科学中最头疼的三件大事中的一件, 我认为说的很对. 在我看来, 命名从来该不是程序员的乾纲独断. 一个类叫什么也不重要, 重要的是有多少人认同了这命名, 要让所有人认同这个名字也就要让所有人识别这个结构. 约定俗成, 这是命名的重中之重, 然而这项工作在实践上是困难的.

OOP中, 最难以令人规避的是名字的多意义性. 解决办法就是给名字加上一节标注, 在C#中叫做命名空间. 这好比我们人类有多重的分类方式, 一只小猫, 我们可以认为是哺乳动物, 也可以认为是陆生动物, 它被解释成什么取决于我们的用途. 在常见的业务层编程中, 一个名字(如订单)可以被定义为多个类. 在物流系统中, 订单持有一个片面的意义; 在结算系统中订单又持有一个片面的意义. 不同的业务部门对名字的解释可谓是盲人摸象. 片面化是名字解释当中最最关键的特征, 是不可缺少. 

我上面说到盲人摸象, 那也得是真的存在一头大象. 有没有可能事实完全相反. 我们只是刚好把不同结构的东西跟这个名字对应起来. 我觉得有可能, 订单就是一个很好的例子.
//下面瞎JR写的, 草稿, 未完待续
面对数不胜数的名字, 和可能

面对这种
//任何一种形式的最基本形式
struct {
	
}
//定义一种长方形
where struct has{
	float & float
} 
//定义一种求面积方法
where result = float * float

//继承
override struct which {
	result = float * float
}
to{
	result = float * float * pi
}


